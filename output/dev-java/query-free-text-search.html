<!DOCTYPE html>
<html lang="en">
<head>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="../../css/prism.css"/><title></title>
</head>
<body>
<h1 >Free Text Search</h1>
<hr>


<h1 id="regular-expressions">Regular Expressions</h1>

<p>You can query the space using the SQL <code>like</code> operator or <a href="http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">rlike - Java Regular Expression</a> Query syntax.</p>

<p>When using the SQL <code>like</code> operator you may use the following:
<code>%</code> - match any string of any length (including zero length)
<code>_</code> - match on a single character</p>

<pre><code class="language-java">SQLQuery&lt;MyClass&gt; query = new SQLQuery&lt;MyClass&gt;(MyClass.class,&quot;name like 'A%'&quot;)
</code></pre>

<p>Querying the space using the <strong>Java Regular Expression</strong> provides more options than the SQL <code>like</code> operator. The Query syntax is done using the <code>rlike</code> operator:</p>

<pre><code class="language-java">// Match all entries of type MyClass that have a name that starts with a or c:
SQLQuery&lt;MyClass&gt; query = new SQLQuery&lt;MyClass&gt;(MyClass.class,&quot;name rlike '(a|c).*'&quot;);
</code></pre>

<p>When you search for space objects with String fields that includes a <strong>single quote</strong> your query should use Parameterized Query - with the following we are searching for all <code>Data</code> objects that include the value <code>today's</code> with their <code>myTextField</code>:</p>

<pre><code class="language-java">String queryStr = &quot;myTextField rlike ?&quot;;
SQLQuery&lt;Data&gt; query = new SQLQuery&lt;Data&gt;(Data.class, queryStr);
query.setParameter(1, &quot;(today\u0027s)&quot;);
Data ret[] = space.readMultiple(query);
</code></pre>

<p>All the Query options are supported both with <code>rlike</code> and <code>like</code> queries.</p>


<div class='bs-callout bs-callout-warning'><p>It is important you index <code>String</code> type fields used with regular expression queries. Not indexing such fields may result slow query execution and garbage creation.</p>
</div>








<h1 id="free-text-search">Free text search</h1>

<p>Free text search is required almost with every application. Users placing some free text into a form and later the system allows users to search for records that includes one or more words within a free text field. A simple way to enable such a search can be done by using an array or a collection of String.</p>

<h1 id="example">Example</h1>

<p>Our Space class includes the following - note the <strong>words</strong> and the <strong>freeText</strong> fields:</p>

<pre><code class="language-java">public class MyData {
String[] words;
String freeText;

public String[] getWords() {
return words;
}

public void setWords(String words[]) {
this.words=words;
}

public String getFreeText() {
return freeText;
}
public void setFreeText(String freeText) {
this.freeText = freeText;
this.words = freeText.split(&quot; &quot;);
}
....
}
</code></pre>


<div class='bs-callout bs-callout-warning'><p>Note how the <strong>freeText</strong> field is broken into the <strong>words</strong> array before placed into the indexed field.</p>
</div>








<p>You may write the data into the space using the following:</p>

<pre><code class="language-java">MyData data = new MyPOJO(...);
data.setFreeText(freetext);
gigaspace.write(data);
</code></pre>

<p>You can query for objects having the word <strong>hello</strong> as part of the freeText field using the following:</p>

<pre><code class="language-java">MyData results[] = gigaspace.readMultiple(new SQLQuery&lt;MyData&gt;(MyData.class, words[*]='hello'));
</code></pre>

<p>You can also execute the following to search for object having the within the freeText field the word <strong>hello</strong> or <strong>everyone</strong>:</p>

<pre><code class="language-java">MyData results[] = gigaspace.readMultiple(new SQLQuery&lt;MyData&gt;(MyData.class, words[*]='hello' OR words[*]='everyone'));
</code></pre>

<p>With the above approach you avoid the overhead with regular expression queries.</p>

<h1 id="indexing">Indexing</h1>

<p>To speed up the query you can create an <a href="./indexing-collections.html">index</a> on the fields you want to search.</p>

<p>Example:</p>

<pre><code class="language-java">public class MyData {
String[] words;
String freeText;

@SpaceIndex (path=&quot;[*]&quot;)
public String[] getWords() {
return words;
}

public void setWords(String words[]) {
this.words=words;
}

public String getFreeText() {
return freeText;
}
public void setFreeText(String freeText) {
this.freeText = freeText;
this.words = freeText.split(&quot; &quot;);
}
....
}
</code></pre>

<div class='bs-callout bs-callout-primary'>
<b style="">See also:</b><br>
<p>The same approach can be implemented also with the <a href="./document-overview.html">SpaceDocument</a>.</p>

</div> 

<h1 id="case-insensitive-query">Case Insensitive Query</h1>

<p>Implementing case insensitive queries can be done via:</p>

<ul>
<li><code>like</code> operator or <code>rlike</code> operator.</li>
<li>Store the data in lower case and query on via lower case String value (or upper case)</li>
</ul>

</body>
<script src="../../js/prism.js"></script>
</html>